{"version":3,"sources":["components/AddCategory.js","helpers/GetGrid.js","components/GifGridItem.js","components/GiffGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setTermino","useState","inputValue","setinputValue","onSubmit","e","preventDefault","trim","length","TerminosAnteriores","type","placeholder","value","onChange","target","getGrid","termino","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","imagen","images","downsized_medium","GifGridItem","className","src","alt","GiffGrid","loading","state","setstate","useEffect","then","useFetchGifs","GifExpertApp","Termino","ReactDOM","render","document","getElementById"],"mappings":"4KAOaA,EAAc,SAAC,GAAsB,IAAnBC,EAAkB,EAAlBA,WAI3B,EAAoCC,mBAFf,IAErB,mBAAOC,EAAP,KAAmBC,EAAnB,KA4BA,OAEI,qCAEI,2CAAeD,EAAf,QAEA,sBAAME,SAzBK,SAAEC,GAGjBA,EAAEC,iBAGGJ,EAAWK,OAAOC,OAAS,IAG5BR,GAAY,SAAAS,GAAkB,OAAOP,GAAP,mBAAsBO,OAGpDN,EAAe,MAaf,SAEI,uBACAO,KAAK,OACLC,YAAY,YACZC,MAAUV,EACVW,SArCU,SAAER,GAEpBF,EAAeE,EAAES,OAAOF,gB,+BCdnBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAGbC,EAHa,iDAGoCC,UAAWH,GAH/C,+DAMAI,MAAOF,GANP,cAMbG,EANa,gBASIA,EAAKC,OATT,uBASXC,EATW,EASXA,KAGFC,EAAOD,EAAKE,KAAK,SAAAC,GAEnB,MAAO,CACHC,GAAKD,EAAIC,GACTC,MAAQF,EAAIE,MACZC,OAASH,EAAII,OAAOC,iBAAiBb,QAjB1B,kBAsBZM,GAtBY,4CAAH,sDCCPQ,EAAc,SAAC,GAAyB,IAAtBJ,EAAqB,EAArBA,MAAOC,EAAc,EAAdA,OAElC,OAEI,mCAIQ,sBAAKI,UAAU,OAAf,UACI,qBAAKC,IAAML,EAASI,UAAU,eAAeE,IAAMP,IACnD,qBAAKK,UAAU,YAAf,SACA,qBAAIA,UAAU,aAAd,cAA8BL,EAA9B,eCRPQ,EAAW,SAAC,GAAmB,IAAhBpB,EAAe,EAAfA,QAGxB,ECHwB,SAAEA,GAG1B,MAA0Bf,mBAAS,CAC/BsB,KAAO,GACPc,SAAU,IAFd,mBAAOC,EAAP,KAAcC,EAAd,KAsBA,OAfAC,qBAAU,WAENzB,EAASC,GAEJyB,MAAM,SAAAZ,GAGHU,EAAS,CACLhB,KAAOM,EACPQ,SAAU,SAGvB,CAAErB,IAGEsB,EDtB8BI,CAAc1B,GAA3CqB,EAAR,EAAQA,QAAgBP,EAAxB,EAAiBP,KAEjB,OAEI,qCAEI,mCAAOP,EAAP,OAEEqB,GAAW,8CAET,qBAAKJ,UAAU,YAAf,SAMQH,EAAOL,KAAK,SAAEI,GAAF,OAER,cAAC,EAAD,eAAmCA,GAAhBA,EAAOF,aEtBzCgB,EAAe,WAGxB,IAGA,EAA8B1C,mBAHT,IAGrB,mBAAO2C,EAAP,KAAgB5C,EAAhB,KAEA,OAEI,qCACI,gGAEA,cAAC,EAAD,CAAaA,WAAaA,IAO1B,uBACA,6BAEQ4C,EAAQnB,KAAK,SAAAT,GAAO,OAEhB,cAAC,EAAD,CAEAA,QAAUA,GADJA,YC3B9B6B,IAASC,OAGL,cAAC,EAAD,IAEFC,SAASC,eAAe,U","file":"static/js/main.96407f38.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\nimport '../index.css'\r\nimport PropTypes from 'prop-types';\r\n\r\n//  Componente Hijo -> Aqui Manejaremos el Input del formulario -> \r\n    //  1. Evitar que la Pagina Recargue\r\n    //  2. Atrapar toda la informacion que el usuario digite en la caja del input\r\nexport const AddCategory = ( { setTermino } ) => {\r\n\r\n    const initialState = '';\r\n\r\n    const [inputValue, setinputValue] = useState(initialState)\r\n\r\n    //  Recibir los datos que el usuario digite en el input\r\n    const ValordelInput = ( e ) => {\r\n\r\n        setinputValue( e.target.value )\r\n    }\r\n\r\n    //  Controlar el Enter emitido del teclado\r\n    const ValorEnter = ( e ) =>{\r\n\r\n        //  Evita que la pagina recargue cuando se envie un formulario\r\n        e.preventDefault()\r\n\r\n        //  Si no se escribe por lo menos dos letras no se realiza el enter \r\n        if ( inputValue.trim().length > 2 ){\r\n\r\n            //  Actualizacion de la categorias -> Categorias + Nuevo Valor Digitado por el Usuario \r\n            setTermino( TerminosAnteriores  => [ inputValue, ...TerminosAnteriores]);\r\n\r\n            //  Resetear Caja del Input \r\n            setinputValue( '' )\r\n\r\n            \r\n        }\r\n\r\n    }\r\n\r\n    return (\r\n\r\n        <>\r\n\r\n            <h1> Buscar: { inputValue }  </h1>\r\n\r\n            <form onSubmit={ ValorEnter }>\r\n\r\n                <input \r\n                type=\"text\"\r\n                placeholder=\"Buscar...\"\r\n                value = { inputValue }\r\n                onChange={ ValordelInput }\r\n                >\r\n                </input>\r\n\r\n            </form>\r\n\r\n        </>\r\n\r\n    )\r\n}\r\n\r\n//  Value -> Valor inicial como un placeHolder\r\n// Onchange -> Recibir el valor que se digite en el input \r\n\r\n\r\n// La Funcion de Actualizacion de Categorias es requerida\r\nAddCategory.propTypes = {\r\n\r\n    setTermino: PropTypes.func.isRequired\r\n\r\n  };","\r\n\r\nexport const getGrid = async( termino ) => {\r\n\r\n    //  URL Para Peticion\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( termino ) }&limit=10&api_key=ToeM5FLqcFLd7vUQpCChh2AAuG5b8Huo`\r\n    \r\n    //  Peticion Fetch -> Require una API URL \r\n    const resp = await fetch( url )\r\n    \r\n    //  Respuesta -> Contenido \r\n    const { data } = await resp.json()\r\n\r\n    //  Retornar solo lo necesario del objeto JSON\r\n    const gifs = data.map( img => {\r\n\r\n        return {\r\n            id : img.id,\r\n            title : img.title,\r\n            imagen : img.images.downsized_medium.url\r\n        }\r\n\r\n    })\r\n\r\n    return gifs\r\n\r\n}","import React from 'react'\r\n\r\n//  Recibimos toda la data del GiffGrid -> En este Componente ya tenemos toda la data para utilizarla \r\nexport const GifGridItem = ( { title, imagen } ) => {\r\n\r\n    return (\r\n\r\n        <>\r\n\r\n\r\n\r\n                <div className=\"card\">\r\n                    <img src={ imagen } className=\"card-img-top\" alt={ title } ></img>\r\n                    <div className=\"card-body\">\r\n                    <h5 className=\"card-title\"> { title } </h5>\r\n\r\n                    </div> \r\n                </div>\r\n\r\n\r\n        </>\r\n\r\n    )\r\n\r\n\r\n}\r\n","import React  from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs'\r\nimport { GifGridItem } from './GifGridItem'\r\n\r\n//  Aqui manejaremos toda la informacion que recibiremos del FETCH API -> \r\n    //  1.  Recibir del Add Category - el termino de busqueda el cual el fetch API  hara la busqueda \r\nexport const GiffGrid = ( { termino } ) => {\r\n\r\n    //  Aqui Mandos a llamar el Hook que tiene el manejo del FetchApi -> use Fetch Gifs \r\n    const { loading, data : images  } =  useFetchGifs( termino )\r\n    \r\n    return (\r\n\r\n        <> \r\n\r\n            <h2> { termino } </h2>\r\n\r\n            { loading && <p> Loading ... </p> }\r\n\r\n                <div className='container'>\r\n\r\n                \r\n\r\n\r\n                    { \r\n                        images.map( ( imagen  ) => (\r\n\r\n                            <GifGridItem key={ imagen.id } {...imagen} />\r\n\r\n                        ))\r\n                        \r\n                    }\r\n\r\n\r\n\r\n\r\n                </div>\r\n                        \r\n        </>\r\n\r\n    )\r\n\r\n}\r\n\r\n","import { useState, useEffect } from \"react\"\r\nimport { getGrid } from \"../helpers/GetGrid\"\r\n\r\n\r\n//  Hook que nos ayuda  con el Fetch de busqueda de Gifts \r\n//  Recibiremos el Termino de Busqueda de Add Category pero dentro del componente del get Grid \r\nexport const useFetchGifs = ( termino ) => {\r\n\r\n    //  Estado Inicial\r\n    const [state, setstate] = useState({\r\n        data : [],\r\n        loading : true\r\n    })\r\n\r\n\r\n    //  Efecto para evitar que se recargue el formulario si no se actualiza el termino \r\n    useEffect(() => {\r\n        //  Usamos el fetch de busqueda de Gifts\r\n        getGrid( termino )\r\n            //  Resolvemos la Promesa retornando la actualizacion de termino de busqueda\r\n            .then( imagen => {\r\n                    //  En este Punto ya se resolvio la Promesa y el argumento( imagen ) -> Contiene toda la data\r\n                    //console.log( imagen )\r\n                setstate({\r\n                    data : imagen,\r\n                    loading : false\r\n                })\r\n            })\r\n    }, [ termino ])\r\n\r\n\r\n    return state\r\n\r\n}\r\n\r\n\r\n\r\n//  Este Hook Va ligado al Fetch API Busqueda de GIFS -> getGrid()\r\n","import React, { useState } from 'react'\r\nimport { AddCategory } from './components/AddCategory'\r\nimport { GiffGrid } from './components/GiffGrid'\r\nimport './index.css'\r\n\r\nexport const GifExpertApp = () => {\r\n\r\n    //  Valores Iniciales de la Aplicacion -> [] Arreglo Vacio \r\n    const initialState = []\r\n\r\n    //  Estado -> Actualizacion del Estado -> Valor Inicial\r\n    const [Termino, setTermino] = useState( initialState )\r\n\r\n    return (\r\n\r\n        <>\r\n            <h1> Aplicacion de REACT  para Busqueda de Gifs con conexion a API</h1>\r\n\r\n            <AddCategory setTermino={ setTermino } />\r\n\r\n            { /*\r\n                1. Componente del Input -> Agregar Termino de Busqueda\r\n                2. Regresar un nuevo Arreglo [ ] \r\n              */ }\r\n\r\n            <hr />\r\n            <ol>\r\n                {\r\n                    Termino.map( termino  => (\r\n\r\n                        <GiffGrid \r\n                        key={ termino } \r\n                        termino={ termino } \r\n                        />\r\n                        \r\n                    ))\r\n                }\r\n            </ol>\r\n            \r\n        </>\r\n\r\n    )\r\n}\r\n\r\n\r\n// Para Comunicarnos de un componente a otro le podemos enviar el useState y poder atrapar informacion de un componente a otro","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { GifExpertApp } from './GifExpertApp';\n\nReactDOM.render(\n\n    //  Inicio de Aplicacion de Busqueda de Gifts -> Verificar si no require ningun argumento de entrada -> argumento = { argumento }\n    <GifExpertApp />,\n\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}